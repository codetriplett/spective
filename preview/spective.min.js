(() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };

  // src/asset.js
  function parseColor(string) {
    const strings = string.slice(1).split("#");
    const integers = [];
    for (const string2 of strings) {
      const chars = string2.split("");
      if (chars.length < 6) {
        const [r, g, b] = chars.splice(0, 3);
        chars.unshift(r, r, g, g, b, b);
      }
      const remainder = chars.length % 3;
      if (remainder === 1)
        chars.push(chars[chars.length - 1]);
      else if (!remainder)
        chars.push("f", "f");
      for (const i of [0, 2, 4, 6]) {
        const first = parseInt(chars[i], 16);
        const second = parseInt(chars[i + 1], 16);
        integers.push((first << 4) + second);
      }
    }
    return new Uint8Array(integers);
  }
  function buildCoordinates(cells, sx = 1, sy = 1, width = 1, height = 1) {
    return cells.map(([x, y]) => {
      const x1 = x / width;
      const y1 = y / height;
      const x2 = (x + sx) / width;
      const y2 = (y + sy) / height;
      return [
        x1,
        y2,
        x2,
        y2,
        x2,
        y1,
        x2,
        y1,
        x1,
        y1,
        x1,
        y2
      ];
    });
  }
  var _Asset, Asset;
  var init_asset = __esm({
    "src/asset.js"() {
      init_node();
      _Asset = class {
        constructor(props = {}) {
          this.texture = void 0;
          this.nodes = /* @__PURE__ */ new Set();
          this.update(Object.assign(_Asset.defaultProps, props));
        }
        update(props = {}) {
          const { texture } = Object.assign(this, props);
          if (typeof texture === "string") {
            if (texture.startsWith("#")) {
              const array = parseColor(texture);
              this._texture = array;
              this._finalizeUpdate(props);
            } else {
              const el = new window.Image();
              el.src = texture;
              this._texture = void 0;
              el.addEventListener("load", () => {
                if (this.texture !== texture)
                  return;
                this._texture = el;
                this._finalizeUpdate(props);
              });
              return;
            }
          }
          this._finalizeUpdate(props);
        }
        _finalizeUpdate(props) {
          let { nodes, tags, cells, sx, sy, _texture } = this;
          let scaleAssumed = false;
          if ("tags" in props && tags === props.tags) {
            const { tags: tags2 } = props;
            const trimedTags = tags2.trim();
            this._tags = trimedTags ? trimedTags.split(/\s+/) : [];
          }
          if ("cells" in props && cells === props.cells) {
            const { cells: cells2 } = props;
            this._cells = cells2 ? cells2.split(" ").map((cell) => cell.split(":").map((it) => Number(it))) : [];
          }
          if ("texture" in props || _texture && "cells" in props) {
            const isColor = _texture instanceof Uint8Array;
            const width = isColor ? _texture.length >> 2 : _texture?.width;
            const height = isColor ? 1 : _texture?.height;
            if (!("sx" in this))
              this.sx = sx = width;
            if (!("sy" in this))
              this.sy = sy = height;
            this._coordinates = buildCoordinates(this._cells, sx, sy, width, height);
            scaleAssumed = true;
          }
          if ("ox" in props || "oy" in props) {
            for (const node of nodes) {
              node._origin = void 0;
            }
          }
          if ("sx" in props || "sy" in props || scaleAssumed) {
            for (const node of nodes) {
              node._scale = void 0;
            }
          }
        }
        add(item = {}) {
          if (!(item instanceof Node)) {
            item = new Node(item);
          }
          item.asset?.remove?.(item);
          item.asset = this;
          Object.assign(item, { _origin: void 0, _scale: void 0 });
          this.nodes.add(item);
          return item;
        }
        remove(item) {
          item.asset = void 0;
          this.nodes.delete(item);
        }
        destroy(relative) {
          const { geometry, nodes } = this;
          if (geometry && geometry !== relative)
            geometry.remove(this);
          for (const node of nodes) {
            node.destroy(this);
          }
        }
      };
      Asset = _Asset;
      __publicField(Asset, "defaultProps", { tags: "", cells: "0:0" });
    }
  });

  // src/matrix.js
  function addMatrices(...matrices) {
    return matrices.reduce((a, b) => [a[0] + b[0], a[1] + b[1]]);
  }
  function multiplyMatrices(...matrices) {
    return matrices.reduce((a, b) => {
      const matrix = [];
      for (let i = 0; i < a.length; i += 2) {
        matrix.push(a[i] * b[0] + a[i + 1] * b[1], a[i] * b[2] + a[i + 1] * b[3]);
      }
      return matrix;
    });
  }
  var init_matrix = __esm({
    "src/matrix.js"() {
    }
  });

  // src/node.js
  var hitboxVertices, _Node, Node;
  var init_node = __esm({
    "src/node.js"() {
      init_asset();
      init_matrix();
      hitboxVertices = [[0, 0], [1, 0], [1, 1], [0, 1]];
      _Node = class {
        constructor(props) {
          Object.assign(this, _Node.defaultProps);
          this.nodes = /* @__PURE__ */ new Set();
          if (props)
            this.update(props);
        }
        update(props = {}) {
          if ("asset" in props) {
            this.asset?.remove?.(this);
            props.asset.add(this);
          }
          if ("group" in props) {
            this.group?.remove?.(this);
            props.group.add(this);
          }
          const { oncollide, collisions } = Object.assign(this, props);
          if ("tags" in props) {
            const { tags } = props;
            const trimedTags = tags.trim();
            this._tags = trimedTags ? trimedTags.split(/\s+/) : [];
          }
          if ("oncollide" in props) {
            if (!oncollide) {
              this.collisions = void 0;
            } else if (!collisions) {
              this.collisions = /* @__PURE__ */ new Set();
            }
          }
          this._finalizeUpdate(props);
        }
        _finalizeUpdate(props) {
          if ("ox" in props || "oy" in props)
            this._origin = void 0;
          if ("px" in props || "py" in props)
            this._position = void 0;
          if ("az" in props)
            this._rotation = void 0;
          if ("sx" in props || "sy" in props)
            this._scale = void 0;
          if ("oxa" in props || "oya" in props || "pxa" in props || "pya" in props || "aza" in props || "sxa" in props || "sya" in props) {
            const { oxa, oya, pxa, pya, aza, sxa, sya } = this;
            this._aActive = !!(oxa || oya || pxa || pya || aza || sxa || sya);
          }
          if ("oxs" in props || "oys" in props || "pxs" in props || "pys" in props || "azs" in props || "sxs" in props || "sys" in props) {
            const { oxs, oys, pxs, pys, azs, sxs, sys } = this;
            this._sActive = !!(oxs || oys || pxs || pys || azs || sxs || sys);
          }
        }
        add(item = {}) {
          if (!(item instanceof _Node)) {
            item = new _Node(item);
          }
          item.group?.remove?.(item);
          item.group = this;
          this.nodes.add(item);
          return item;
        }
        remove(item) {
          item.group = void 0;
          this.nodes.delete(item);
        }
        destroy(relative) {
          const { group, asset, nodes } = this;
          if (group && group !== relative)
            group.remove(this);
          if (asset && asset !== relative)
            asset.remove(this);
          for (const node of nodes) {
            node.destroy(this);
          }
        }
        find(query, limit) {
          const { nodes } = this;
          const matches = [];
          if (typeof query === "string") {
            const queries = query.split(",").map((query2) => {
              return query2.trim().split(/\s+/).map((query3) => {
                return query3.split(".");
              });
            });
            return this._findFromQueries(queries, limit);
          } else if (typeof query !== "function") {
            return matches;
          } else if (query(this)) {
            matches.push(this);
            limit -= 1;
          }
          for (const node of nodes) {
            if (limit <= 0)
              break;
            const nodeMatches = node.find(query, limit);
            matches.push(...nodeMatches);
            limit -= nodeMatches.length;
          }
          return matches;
        }
        _findFromQueries(queries, limit) {
          const matches = [];
          const { _tags = [], asset, nodes } = this;
          const allTags = asset ? [...asset._tags, ..._tags] : _tags;
          const type = asset?.type || "";
          const childQueries = [];
          let didMatch = false;
          for (const [expected, ...remaining] of queries) {
            const [expectedType, ...expectedTags] = expected;
            if (expectedType !== type)
              continue;
            const isMatch = expectedTags.every((expected2) => allTags.some((tag) => tag === expected2));
            if (!isMatch)
              continue;
            if (remaining.length)
              childQueries.push(remaining);
            else
              didMatch = true;
          }
          if (didMatch) {
            matches.push(this);
            limit -= 1;
          }
          childQueries.push(...queries);
          for (const node of nodes) {
            if (limit <= 0)
              break;
            const childMatches = node._findFromQueries(childQueries, limit);
            matches.push(...childMatches);
            limit -= childMatches.length;
          }
          return matches;
        }
        paint(item = {}) {
          if (!(item instanceof Asset)) {
            item = new Asset(item);
          }
          const { asset } = this;
          if (asset) {
            asset.nodes.delete(this);
          }
          item.add(this);
          return item;
        }
        _applyPhysics(elapsedTime, frameCount) {
          const { group, _lastPhysicsFrame } = this;
          if (_lastPhysicsFrame === frameCount)
            return;
          if (group)
            group._applyPhysics(elapsedTime, frameCount);
          this._lastPhysicsFrame = frameCount;
          let { _aActive, _sActive, oxs, oys, pxs, pys, azs, sxs, sys } = this;
          const props = {};
          if (_aActive) {
            const { oxa, oya, pxa, pya, aza, sxa, sya } = this;
            if (oxa)
              props.oxs = oxs += oxa * elapsedTime;
            if (oya)
              props.oys = oys += oya * elapsedTime;
            if (pxa)
              props.pxs = pxs += pxa * elapsedTime;
            if (pya)
              props.pys = pys += pya * elapsedTime;
            if (aza)
              props.azs = azs += aza * elapsedTime;
            if (sxa)
              props.sxs = sxs += sxa * elapsedTime;
            if (sya)
              props.sys = sys += sya * elapsedTime;
          } else if (!_sActive) {
            return;
          }
          const { ox, oy, px, py, az, sx, sy } = this;
          if (oxs)
            props.ox = ox + oxs * elapsedTime;
          if (oys)
            props.oy = oy + oys * elapsedTime;
          if (pxs)
            props.px = px + pxs * elapsedTime;
          if (pys)
            props.py = py + pys * elapsedTime;
          if (azs)
            props.az = az + azs * elapsedTime;
          if (sxs)
            props.sx = sx + sxs * elapsedTime;
          if (sys)
            props.sy = sy + sys * elapsedTime;
          this.update(props);
        }
        _recalculate(frameCount, relative) {
          const { group } = this;
          if (group)
            group._recalculate(frameCount, this);
          let { asset, nodes, _composite, _position, _origin, _rotation, _scale, _inverted } = this;
          if (_composite && _position && _origin && _rotation && _scale)
            return;
          this._lastCalculatedFrame = frameCount;
          if (!_rotation || !_scale) {
            if (!_rotation) {
              const { az } = this;
              const cos = Math.cos(az);
              const sin = Math.sin(az);
              this._rotation = [cos, -sin, sin, cos];
            }
            if (!_scale) {
              let { sx, sy } = this;
              if (asset) {
                sx *= asset.sx || 1;
                sy *= asset.sy || 1;
              }
              this._scale = _inverted ? [1 / sx, 0, 0, 1 / sy] : [sx, 0, 0, sy];
            }
            ({ _rotation, _scale } = this);
            this._matrix = _inverted ? multiplyMatrices(_scale, _rotation) : multiplyMatrices(_rotation, _scale);
            _origin = void 0;
          }
          const { _matrix } = this;
          this._composite = group ? multiplyMatrices(group._composite, _matrix) : _matrix;
          if (!_position || !_composite) {
            const { px, py } = this;
            let position = _inverted ? [-px, -py] : [px, py];
            if (group) {
              position = multiplyMatrices(position, group._composite);
              position = addMatrices(position, group._position);
            }
            this._position = position;
          }
          if (!_origin || !_composite) {
            let { ox, oy, _composite: _composite2 } = this;
            if (asset) {
              ox += asset.ox || 0;
              oy += asset.oy || 0;
            }
            this._origin = multiplyMatrices(_inverted ? [ox, oy] : [-ox, -oy], _composite2);
          }
          for (const node of nodes) {
            node._composite = void 0;
            if (node === relative)
              continue;
            node._recalculate(frameCount, this);
          }
        }
        _recalculateBoundaries() {
          const { _composite, _position, _origin, _boundaries } = this;
          const vertices = hitboxVertices.map((vertex2) => {
            const multipliedVertex = multiplyMatrices(vertex2, _composite);
            return addMatrices(multipliedVertex, _position, _origin);
          });
          const xValues = vertices.map((vertex2) => vertex2[0]);
          const yValues = vertices.map((vertex2) => vertex2[1]);
          const left = Math.min(...xValues);
          const right = Math.max(...xValues);
          const bottom = Math.min(...yValues);
          const top = Math.max(...yValues);
          this._boundaries = [left, right, bottom, top];
        }
      };
      Node = _Node;
      __publicField(Node, "defaultProps", {
        ox: 0,
        oy: 0,
        px: 0,
        py: 0,
        az: 0,
        sx: 1,
        sy: 1,
        oxs: 0,
        oys: 0,
        oxa: 0,
        oya: 0,
        pxs: 0,
        pys: 0,
        pxa: 0,
        pya: 0,
        azs: 0,
        aza: 0,
        sxs: 0,
        sys: 0,
        sxa: 0,
        sya: 0,
        cell: 0
      });
    }
  });

  // src/geometry.js
  var defaultMesh, _Geometry, Geometry;
  var init_geometry = __esm({
    "src/geometry.js"() {
      init_asset();
      defaultMesh = [
        0,
        0,
        0,
        1,
        0,
        0,
        1,
        1,
        0,
        1,
        1,
        0,
        0,
        1,
        0,
        0,
        0,
        0
      ];
      _Geometry = class {
        constructor(props = {}) {
          this.joints = Object.assign(new Asset(), { geometry: this });
          this.assets = /* @__PURE__ */ new Set();
          this.update({ ..._Geometry.defaultProps, ...props });
        }
        // TODO: force mesh to be a lteral that can be compared between rendered
        // - url to .obj file or primiative definition like in old spective
        // - this isn't needed for sprites, but would need to be implemented for 3D objects
        update(props = {}) {
          Object.assign(this, props);
          if ("mesh" in props)
            this._mesh = props.mesh;
        }
        add(item = {}) {
          if (!("texture" in item)) {
            const joint = this.joints.add(item);
            joint._recalculate(0);
            return joint;
          } else if (!(item instanceof Asset)) {
            item = new Asset(item);
          }
          item.geometry?.remove?.(item);
          item.geometry = this;
          this.assets.add(item);
          return item;
        }
        remove(item) {
          this.assets.delete(item);
        }
        destroy(relative) {
          const { layer, assets } = this;
          if (layer && layer !== relative)
            layer.remove(this);
          for (const asset of assets) {
            asset.destroy(this);
          }
        }
      };
      Geometry = _Geometry;
      __publicField(Geometry, "defaultProps", { mesh: defaultMesh });
    }
  });

  // src/layer.js
  var _Layer, Layer;
  var init_layer = __esm({
    "src/layer.js"() {
      init_geometry();
      _Layer = class {
        constructor(props = {}) {
          this.library = Object.assign(new Geometry(), { layer: this });
          this.geometries = /* @__PURE__ */ new Set();
          this.update({ ..._Layer.defaultProps, ...props });
        }
        update(props = {}) {
          Object.assign(this, props);
        }
        add(item = {}) {
          if (!("mesh" in item)) {
            return this.library.add(item);
          } else if (!(item instanceof Geometry)) {
            item = new Geometry(item);
          }
          item.layer?.remove?.(item);
          item.layer = this;
          this.geometries.add(item);
          return item;
        }
        remove(item) {
          this.geometries.delete(item);
        }
        destroy(relative) {
          const { scene, geometries } = this;
          if (scene && scene !== relative)
            scene.remove(this);
          for (const geometry of geometries) {
            geometry.destroy(this);
          }
        }
      };
      Layer = _Layer;
      __publicField(Layer, "defaultProps", { parallax: 1 });
    }
  });

  // src/program.js
  function compileShader(gl, code, type) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, code);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      console.log(
        `Error compiling ${type === gl.VERTEX_SHADER ? "vertex" : "fragment"} shader:`
      );
      console.log(gl.getShaderInfoLog(shader));
    }
    return shader;
  }
  function createProgram(gl) {
    const program = gl.createProgram();
    const vertexShader = compileShader(gl, vertex, gl.VERTEX_SHADER);
    if (vertexShader)
      gl.attachShader(program, vertexShader);
    const fragmentShader = compileShader(gl, fragment, gl.FRAGMENT_SHADER);
    if (fragmentShader)
      gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      console.log("Error linking shader program:");
      console.log(gl.getProgramInfoLog(program));
    }
    return program;
  }
  var vertex, fragment;
  var init_program = __esm({
    "src/program.js"() {
      vertex = `
	attribute vec3 aVertex;
	attribute vec2 aCoordinate;

	uniform mat2 uMatrix;
	uniform vec2 uPosition;
	uniform vec2 uOrigin;
	uniform float uLayerParallax;
	uniform float uLayerSquash;
	uniform float uLayerDepth;
	uniform mat2 uSceneMatrix;
	uniform vec2 uScenePosition;
	uniform vec2 uSceneOrigin;

	varying vec2 vCoordinate;

	void main() {
		vec2 sceneShift = (uScenePosition + uSceneOrigin) * uLayerParallax;
		vec2 vertex = aVertex.xy * uMatrix + uPosition + uOrigin + sceneShift;
		float depth = aVertex.z * uLayerSquash + uLayerDepth;
		gl_Position = vec4(vertex * uSceneMatrix, -depth, 1.0);
		vCoordinate = aCoordinate;
	}
`;
      fragment = `
	precision mediump float;

	uniform sampler2D uImage;

	varying vec2 vCoordinate;

	void main() {
		vec4 pixel = texture2D(uImage, vCoordinate);
		gl_FragColor = pixel;
	}
`;
    }
  });

  // src/scene.js
  function setAttribute(gl, location, buffer, dims, array) {
    const { ARRAY_BUFFER, STATIC_DRAW, FLOAT } = gl;
    gl.bindBuffer(ARRAY_BUFFER, buffer);
    gl.enableVertexAttribArray(location);
    gl.bufferData(ARRAY_BUFFER, new Float32Array(array), STATIC_DRAW);
    gl.vertexAttribPointer(location, dims, FLOAT, false, 0, 0);
  }
  function compareBoundaries(activeNodes, passiveNodes, frameCount, flipResolution) {
    const inactiveNodes = [];
    for (let activeNode of activeNodes) {
      const { _lastCalculatedFrame, _boundaries: a } = activeNode;
      if (_lastCalculatedFrame !== frameCount) {
        inactiveNodes.push(activeNode);
        continue;
      }
      for (let passiveNode of passiveNodes) {
        if (passiveNode === activeNode)
          continue;
        const { _boundaries: a2 } = activeNode;
        const { _boundaries: b } = passiveNode;
        let overlap = [b[1] - a2[0], a2[1] - b[0], b[3] - a2[2], a2[3] - b[2]];
        const areTouching = overlap.every((value) => value >= 0);
        if (flipResolution) {
          const [left, right, bottom, top] = overlap;
          overlap = [right, left, top, bottom];
          const _activeNode = activeNode;
          activeNode = passiveNode;
          passiveNode = _activeNode;
        }
        const { collisions, oncollide } = activeNode;
        if (areTouching === collisions.has(passiveNode))
          continue;
        const minOverlap = Math.min(...overlap);
        const side = overlap.indexOf(minOverlap);
        const { param } = passiveNode;
        const event = {
          overlap,
          side,
          param,
          type: areTouching ? COLLIDE_ACTION : SEPARATE_ACTION,
          action: areTouching ? "collide" : "separate",
          self: activeNode,
          node: passiveNode
        };
        const props = oncollide(event);
        if (props) {
          const direction = side % 2 ? -1 : 1;
          const clonedProps = { ...props };
          if (side < 2 && !("px" in clonedProps)) {
            clonedProps.px = activeNode.px + overlap[side] * direction;
          } else if (side > 1 && !("py" in clonedProps)) {
            clonedProps.py = activeNode.py + overlap[side] * direction;
          }
          activeNode.update(clonedProps);
        } else if (areTouching) {
          collisions.add(passiveNode);
        } else {
          collisions.delete(passiveNode);
        }
      }
    }
    return inactiveNodes;
  }
  var COLLIDE_ACTION, SEPARATE_ACTION, Scene;
  var init_scene = __esm({
    "src/scene.js"() {
      init_node();
      init_layer();
      init_program();
      COLLIDE_ACTION = "COLLIDE_ACTION";
      SEPARATE_ACTION = "SEPARATE_ACTION";
      Scene = class extends Node {
        constructor(props) {
          super();
          this.ui = Object.assign(new Layer(), { scene: this });
          this.layers = [];
          this._inverted = true;
          if (props)
            this.update(props);
        }
        update(props = {}) {
          Object.assign(this, props);
          this._finalizeUpdate(props);
          if (!("gl" in this)) {
            let { density = 2, canvas, div, width, height } = this;
            if (!canvas) {
              const { width: width2 = 640, height: height2 = 360 } = props;
              this.canvas = canvas = document.createElement("canvas");
              document.body.appendChild(canvas);
              Object.assign(canvas, {
                width: Math.round(width2 * density),
                height: Math.round(height2 * density)
              });
              const styles = {
                position: "absolute",
                left: "50vw",
                top: "0",
                width: `${width2 / height2 * 100}vh`,
                height: "100vh",
                transform: "translateX(-50%)"
              };
              Object.assign(canvas.style, styles);
              if (div)
                Object.assign(div.style, { ...styles, zIndex: 1 });
            }
            if (width === void 0)
              width = canvas.width / density;
            if (height === void 0)
              height = canvas.height / density;
            this.asset = { ox: 0, oy: 0, sx: width / 2, sy: height / 2 };
            const gl = canvas.getContext("webgl");
            const program = createProgram(gl);
            gl.clearColor(0.5, 0.5, 0.5, 0.5);
            gl.useProgram(program);
            this.gl = gl;
            this.aVertex = gl.getAttribLocation(program, "aVertex");
            this.aCoordinate = gl.getAttribLocation(program, "aCoordinate");
            this.uMatrix = gl.getUniformLocation(program, "uMatrix");
            this.uPosition = gl.getUniformLocation(program, "uPosition");
            this.uOrigin = gl.getUniformLocation(program, "uOrigin");
            this.uLayerParallax = gl.getUniformLocation(program, "uLayerParallax");
            this.uLayerSquash = gl.getUniformLocation(program, "uLayerSquash");
            this.uLayerDepth = gl.getUniformLocation(program, "uLayerDepth");
            this.uSceneMatrix = gl.getUniformLocation(program, "uSceneMatrix");
            this.uScenePosition = gl.getUniformLocation(program, "uScenePosition");
            this.uSceneOrigin = gl.getUniformLocation(program, "uSceneOrigin");
            gl.enable(gl.DEPTH_TEST);
            gl.blendEquation(gl.FUNC_ADD);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
            this._frameCount = 0;
            setTimeout(() => this._animate(), 0);
            document.addEventListener("visibilitychange", () => {
              if (document.hidden)
                this.pause();
              else
                this.resume();
            });
          }
        }
        add(item = {}) {
          if (!("parallax" in item)) {
            return this.ui.add(item);
          } else if (!(item instanceof Layer)) {
            item = new Layer(item);
          }
          const { layers } = this;
          if (layers.indexOf(item) === -1) {
            item.scene?.remove?.(item);
            layers.push(item);
          }
          item.scene = this;
          layers.sort((a, b) => a.parallax - b.parallax);
          return item;
        }
        remove(item) {
          const { layers } = this;
          const index = layers.indexOf(item);
          if (index === -1)
            return;
          layers.splice(index, 1);
        }
        destroy() {
          for (const layer of this.layers) {
            layer.destroy(this);
          }
        }
        _renderGeometry(geometry) {
          const { gl, aVertex, aCoordinate, uMatrix, uPosition, uOrigin } = this;
          const { TEXTURE_2D, CLAMP_TO_EDGE, RGBA, TRIANGLES } = gl;
          if (!("_glBuffer" in geometry)) {
            geometry._glBuffer = gl.createBuffer();
          }
          const { mesh, assets, _glBuffer } = geometry;
          setAttribute(gl, aVertex, _glBuffer, 3, mesh);
          for (const asset of assets) {
            if (!("_glTexture" in asset)) {
              asset._glTexture = gl.createTexture();
            }
            if (!("_glBuffer" in asset)) {
              asset._glBuffer = gl.createBuffer();
            }
            const { _texture, _coordinates, width, height, nodes, _glTexture, _glBuffer: _glBuffer2 } = asset;
            if (_texture === void 0)
              continue;
            let dimensions = [];
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(TEXTURE_2D, _glTexture);
            if (_texture instanceof Uint8Array) {
              dimensions = [width, height, 0];
            } else {
              gl.texParameteri(TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
              gl.texParameteri(TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
              gl.texParameteri(TEXTURE_2D, gl.TEXTURE_WRAP_S, CLAMP_TO_EDGE);
              gl.texParameteri(TEXTURE_2D, gl.TEXTURE_WRAP_T, CLAMP_TO_EDGE);
            }
            gl.texImage2D(TEXTURE_2D, 0, RGBA, ...dimensions, RGBA, gl.UNSIGNED_BYTE, _texture);
            for (const node of nodes) {
              const { cell, _position, _origin, _composite } = node;
              setAttribute(gl, aCoordinate, _glBuffer2, 2, _coordinates[cell]);
              gl.uniformMatrix2fv(uMatrix, false, _composite);
              gl.uniform2fv(uPosition, _position);
              gl.uniform2fv(uOrigin, _origin);
              gl.drawArrays(TRIANGLES, 0, 6);
            }
          }
        }
        render(elapsedTime) {
          const { gl, ui, layers, _frameCount } = this;
          const allLayers = [...layers, ui];
          const nodesByLayer = allLayers.map(({ library, geometries }) => {
            const allNodes = [...library.joints.nodes];
            for (const { assets } of [library, ...geometries]) {
              for (const { nodes } of assets) {
                allNodes.push(...nodes);
              }
            }
            return allNodes;
          });
          this._applyPhysics(elapsedTime, _frameCount);
          for (const nodes of nodesByLayer) {
            for (const node of nodes) {
              node._applyPhysics(elapsedTime, _frameCount);
            }
          }
          if (this.ondraw) {
            this.ondraw(elapsedTime, _frameCount);
          }
          for (const nodes of nodesByLayer) {
            const listeners = [];
            const triggers = [];
            for (const node of nodes) {
              const { param, oncollide } = node;
              if (!oncollide && param === void 0)
                continue;
              if (oncollide)
                listeners.push(node);
              if (param !== void 0)
                triggers.push(node);
              node._recalculate(_frameCount);
              node._recalculateBoundaries(_frameCount);
            }
            const remainingListeners = compareBoundaries(listeners, triggers, _frameCount);
            compareBoundaries(triggers, remainingListeners, _frameCount, true);
          }
          this._recalculate(_frameCount);
          for (const nodes of nodesByLayer) {
            for (const node of nodes) {
              node._recalculate(_frameCount);
            }
          }
          const { uSceneMatrix, uScenePosition, uSceneOrigin, uLayerParallax, uLayerSquash, uLayerDepth, _matrix, _position, _origin, _scale } = this;
          gl.clear(gl.COLOR_BUFFER_BIT);
          gl.uniformMatrix2fv(uSceneMatrix, false, _matrix);
          gl.uniform2fv(uScenePosition, _position);
          gl.uniform2fv(uSceneOrigin, _origin);
          const layerSquash = 2 / allLayers.length;
          gl.uniform1f(uLayerSquash, layerSquash);
          gl.depthMask(true);
          gl.disable(gl.BLEND);
          let layerDepth = 1 - layerSquash / 2;
          for (let i = allLayers.length - 1; i >= 0; i--) {
            const { parallax, geometries } = allLayers[i];
            gl.uniform1f(uLayerParallax, parallax);
            gl.uniform1f(uLayerDepth, layerDepth);
            layerDepth -= layerSquash;
            for (const geometry of geometries) {
              this._renderGeometry(geometry);
            }
          }
          gl.depthMask(false);
          gl.enable(gl.BLEND);
          layerDepth = -1 + layerSquash / 2;
          for (const layer of allLayers) {
            const { parallax, library } = layer;
            if (layer === ui) {
              gl.uniformMatrix2fv(uSceneMatrix, false, _scale);
            }
            gl.uniform1f(uLayerParallax, parallax);
            gl.uniform1f(uLayerDepth, layerDepth);
            layerDepth += layerSquash;
            this._renderGeometry(library);
          }
          this._frameCount++;
        }
        _animate(elapsedTime = 0) {
          this.render(elapsedTime);
          requestAnimationFrame((currentTime) => {
            if (this._paused)
              return;
            const { _previousTime = currentTime } = this;
            this._previousTime = currentTime;
            const elapsedTime2 = (_previousTime && currentTime - _previousTime) / 1e3;
            this._animate(elapsedTime2);
          });
        }
        resume() {
          if (!this._paused)
            return;
          this._paused = false;
          this._animate();
        }
        pause() {
          if (this._paused)
            return;
          this._paused = true;
          this._previousTime = void 0;
        }
      };
      __publicField(Scene, "defaultProps", {});
    }
  });

  // src/control.js
  function hold(control, event) {
    controls.add(control);
    control.activate(event);
  }
  function release(control, event) {
    controls.delete(control);
    control.deactivate(event);
  }
  function resolveKey({ key, repeat }, callback) {
    if (repeat)
      return;
    const control = keyControls[key];
    if (!control)
      return;
    callback(control, { type: KEY_INPUT, input: "key", control });
  }
  function resolveTouch(event, callback, control) {
    event.preventDefault();
    callback(control, { type: TOUCH_INPUT, input: "touch", control });
  }
  var controls, keyControls, KEY_INPUT, TOUCH_INPUT, Control;
  var init_control = __esm({
    "src/control.js"() {
      controls = /* @__PURE__ */ new Set();
      keyControls = {};
      KEY_INPUT = "KEY_INPUT";
      TOUCH_INPUT = "TOUCH_INPUT";
      window.addEventListener("keydown", (event) => resolveKey(event, hold));
      window.addEventListener("keyup", (event) => resolveKey(event, release));
      Control = class {
        constructor(info, ondown, onup) {
          const { key, el } = info;
          if (key)
            keyControls[key] = this;
          if (el) {
            el.addEventListener("mousedown", (event) => resolveTouch(event, hold, this));
            el.addEventListener("mouseup", (event) => resolveTouch(event, release, this));
            el.addEventListener("touchstart", (event) => resolveTouch(event, hold, this), { passive: false });
            el.addEventListener("touchend", (event) => resolveTouch(event, release, this), { passive: false });
          }
          this.ondown = ondown;
          this.onup = onup;
        }
        activate(event) {
          this.ondown(event);
        }
        deactivate(event) {
          if (!this.onup)
            return;
          this.onup(event);
        }
      };
    }
  });

  // src/index.js
  function updater(item, props, prevNames, defaultProps2) {
    if (prevNames) {
      prevNames = new Set(prevNames);
      const changedEntries = Object.entries(props).filter(([name, value]) => {
        prevNames.delete(name);
        return value !== item[name] && (name.length > 3 || value !== void 0);
      });
      for (const name of prevNames) {
        changedEntries.push([name, defaultProps2[name]]);
      }
      if (!changedEntries.length)
        return;
      props = Object.fromEntries(changedEntries);
    } else {
      const id = props.id;
      if (id && (!Object.prototype.hasOwnProperty.call(window, id) || window[id]._instance === item)) {
        window[id] = item;
      }
    }
    item.update(props);
  }
  function spective(...params) {
    const [props = {}] = params;
    return "key" in props ? new Control(...params) : new Scene(...params);
  }
  var document2, defaultProps, framework, LEFT, RIGHT, BOTTOM, TOP;
  var init_src = __esm({
    "src/index.js"() {
      init_scene();
      init_layer();
      init_geometry();
      init_asset();
      init_node();
      init_control();
      document2 = {
        createTextNode() {
          return;
        },
        createDocumentFragment() {
          return {
            childNodes: [],
            appendChild(child) {
              this.removeChild(child);
              this.childNodes.push(child);
              child.parentElement = this;
            },
            insertBefore(child, sibling) {
              const { childNodes } = this;
              this.removeChild(child);
              const index = childNodes.indexOf(sibling);
              childNodes.splice(index, 0, child);
              child.parentElement = this;
            },
            removeChild(child) {
              const { childNodes } = this;
              const index = childNodes.indexOf(child);
              if (index === -1)
                return;
              childNodes.splice(index, 1);
              child.parentElement = null;
            }
          };
        },
        createElement(tagName) {
          tagName = tagName.toLowerCase();
          const element = new {
            scene: Scene,
            layer: Layer,
            geometry: Geometry,
            asset: Asset,
            node: Node
          }[tagName]();
          return Object.assign(element, {
            tagName,
            childNodes: [],
            appendChild: (item) => element.add(item),
            insertBefore: (item) => element.add(item),
            removeChild: (item) => item.destroy()
          });
        }
      };
      defaultProps = {
        scene: Scene.defaultProps,
        layer: Layer.defaultProps,
        geometry: Geometry.defaultProps,
        asset: Asset.defaultProps,
        node: Node.defaultProps
      };
      framework = [document2, updater, defaultProps];
      LEFT = 0;
      RIGHT = 1;
      BOTTOM = 2;
      TOP = 3;
    }
  });

  // src/module.js
  var init_module = __esm({
    "src/module.js"() {
      init_scene();
      init_layer();
      init_geometry();
      init_asset();
      init_node();
      init_control();
      init_src();
    }
  });

  // src/main.js
  var require_main = __commonJS({
    "src/main.js"(exports, module) {
      init_module();
      Object.assign(spective, {
        Scene,
        Layer,
        Geometry,
        Asset,
        Node,
        Control,
        controls,
        framework,
        LEFT,
        RIGHT,
        BOTTOM,
        TOP,
        COLLIDE_ACTION,
        SEPARATE_ACTION,
        KEY_INPUT,
        TOUCH_INPUT
      });
      if (typeof window === "object") {
        window.spective = spective;
      } else if (typeof module === "object") {
        module.exports = spective;
      }
    }
  });
  require_main();
})();
/**
 * @license MIT
 * Copyright (c) 2023 Jeff Triplett
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
